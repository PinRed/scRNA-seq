# Project all data into PCA space
expr_hvg_DEA_filtered <- expr_all[rownames(res[res$significant == 'yes',]), ]
expr_hvg_DEA_scaled <- scale(t(expr_hvg_DEA_filtered),
center = pca_hvg_DEA$center,
scale = pca_hvg_DEA$scale)
pca_scores_HVG <- expr_hvg_DEA_scaled %*% pca_hvg_DEA$rotation
# Plot
plot(pca_scores_HVG[,1], pca_scores_HVG[,2],
col = as.numeric(group_all), pch = 16,
xlab = "PC1", ylab = "PC2", main = "PCA: All Genes DEA")
legend("topright", legend = levels(group_all),
col = 1:length(levels(group_all)), pch = 16)
# Plot
plot(pca_scores_HVG[,1], pca_scores_HVG[,2],
col = as.numeric(group_all), pch = 16,
xlab = "PC1", ylab = "PC2", main = "PCA: HVG DEA")
#### Sparse PCA ####
spca_res <- spca(t(expr_f), k = 2, alpha = 0.01, max_iter = 200, scale = TRUE)
pca_spca_scores <- t(expr_all_filtered) %*% spca_res$loadings[, 1:2]
# Plot Sparse PCA
plot(pca_spca_scores[,1], pca_spca_scores[,2],
col = as.numeric(group_all), pch = 16,
xlab = "Sparse PC1", ylab = "Sparse PC2",
main = paste0("Sparse PCA: [", nrow(expr_f), ", ", ncol(expr_f), "]"))
legend("topright", legend = levels(group_all),
col = 1:length(levels(group_all)), pch = 16)
# Non-zero loadings count
cat("PC1 non-zero loadings:", sum(spca_res$loadings[,1] != 0), "\n")
cat("PC2 non-zero loadings:", sum(spca_res$loadings[,2] != 0), "\n")
# Sparse PCA 選出的基因矩陣
expr_spca <- as.matrix(expr_spca)
# Sparse PCA 選出的基因矩陣
expr_spca <- as.matrix(expr_spca)
expr_spca <- expr_f[spca_res$loadings[,1] != 0,]
# Sparse PCA 選出的基因矩陣
expr_spca <- as.matrix(expr_spca)
# Design matrix
design <- model.matrix(~ group)
colnames(design) <- c("Intercept", "TumorVsNormal")
# Fit linear model + Empirical Bayes
fit <- lmFit(expr_spca, design)
fit <- eBayes(fit, trend=TRUE)
# 取得 DEA 結果
res_spca <- topTable(fit, coef="TumorVsNormal", number=Inf, adjust.method="BH")
# 定義顯著基因
alpha <- 0.05
logFC_cut <- 1
res_spca$significant <- ifelse(res_spca$adj.P.Val < alpha & abs(res_spca$logFC) > logFC_cut, "yes", "no")
# 對應 gene names（假設 TCGA.temp2 有對應名稱）
res_spca$names <- TCGA.temp2[rownames(res_spca), 1]
# Volcano plot
ggplot(res_spca, aes(x = logFC, y = -log10(P.Value), color = significant)) +
geom_point(alpha = 0.6) +
scale_color_manual(values = c("no" = "grey", "yes" = "red")) +
theme_minimal(base_size = 14) +
labs(title = "Volcano Plot: Tumor vs Normal (Sparse PCA genes, limma DEA)",
x = "log2 Fold Change",
y = "-log10(p-value)") +
geom_text_repel(data = subset(res_spca, significant == "yes"),
aes(label = names), size = 3)
spca_res$loadings[,1] != 0
# Non-zero loadings count
cat("PC1 non-zero loadings:", sum(spca_res$loadings[,1] != 0), "\n")
cat("PC2 non-zero loadings:", sum(spca_res$loadings[,2] != 0), "\n")
# Plot Sparse PCA
plot(pca_spca_scores[,1], pca_spca_scores[,2],
col = as.numeric(group_all), pch = 16,
xlab = "Sparse PC1", ylab = "Sparse PC2",
main = paste0("Sparse PCA: [337, 26]"))
expr_spca <- expr_f[rowSums(spca_res$loadings[,1:2] != 0) > 0, ]
dim(expr_spca)
# Sparse PCA 選出的基因矩陣
expr_spca <- as.matrix(expr_spca)
# Design matrix
design <- model.matrix(~ group)
colnames(design) <- c("Intercept", "TumorVsNormal")
# Fit linear model + Empirical Bayes
fit <- lmFit(expr_spca, design)
fit <- eBayes(fit, trend=TRUE)
# 取得 DEA 結果
res_spca <- topTable(fit, coef="TumorVsNormal", number=Inf, adjust.method="BH")
# 定義顯著基因
alpha <- 0.05
logFC_cut <- 1
res_spca$significant <- ifelse(res_spca$adj.P.Val < alpha & abs(res_spca$logFC) > logFC_cut, "yes", "no")
# 對應 gene names（假設 TCGA.temp2 有對應名稱）
res_spca$names <- TCGA.temp2[rownames(res_spca), 1]
# Volcano plot
ggplot(res_spca, aes(x = logFC, y = -log10(P.Value), color = significant)) +
geom_point(alpha = 0.6) +
scale_color_manual(values = c("no" = "grey", "yes" = "red")) +
theme_minimal(base_size = 14) +
labs(title = "Volcano Plot: Tumor vs Normal (Sparse PCA genes, limma DEA)",
x = "log2 Fold Change",
y = "-log10(p-value)") +
geom_text_repel(data = subset(res_spca, significant == "yes"),
aes(label = names), size = 3)
sum(res_spca$significant == 'yes')
#### PCA - DEA for SPCA ####
pca_hvg_DEA <- prcomp(t(expr_f[rownames(res_spca[res_spca$significant == 'yes',]),]), scale. = TRUE)
# Project all data into PCA space
expr_hvg_DEA_filtered <- expr_all[rownames(res_spca[res_spca$significant == 'yes',]), ]
expr_hvg_DEA_scaled <- scale(t(expr_hvg_DEA_filtered),
center = pca_hvg_DEA$center,
scale = pca_hvg_DEA$scale)
pca_scores_HVG <- expr_hvg_DEA_scaled %*% pca_hvg_DEA$rotation
# Plot
plot(pca_scores_HVG[,1], pca_scores_HVG[,2],
col = as.numeric(group_all), pch = 16,
xlab = "PC1", ylab = "PC2", main = "PCA: HVG DEA")
legend("topright", legend = levels(group_all),
col = 1:length(levels(group_all)), pch = 16)
source("C:/Users/User/Desktop/program/utaipei_RA/code_TCGA_CRC_forWillie.r/code_TCGA_CRC_forWillie.r", echo = TRUE)
dim(sample_cor)
# rownames(sig_genes), top_hvg,
# 繪製 heatmap
pheatmap(sample_cor,
main = "HVG cor",
clustering_distance_rows = "euclidean",  # 樣本聚類距離
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("blue", "white", "red"))(100),
show_rownames = TRUE,
show_colnames = TRUE
)
# rownames(sig_genes), top_hvg,
# 繪製 heatmap
pheatmap(sample_cor,
main = "HVG cor",
clustering_distance_rows = "euclidean",  # 樣本聚類距離
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("blue", "white", "red"))(100),
show_rownames = TRUE,
show_colnames = TRUE
)
rownames(expr_spca)
# expr_spca_data: 基因 x 樣本矩陣
# 計算樣本間 Pearson 相關性矩陣
sample_cor <- cor(t(expr_f[rownames(expr_spca),]))  # 默認 method="pearson"
dim(sample_cor)
# rownames(sig_genes), top_hvg,
# 繪製 heatmap
pheatmap(sample_cor,
main = "HVG cor",
clustering_distance_rows = "euclidean",  # 樣本聚類距離
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("blue", "white", "red"))(100),
show_rownames = TRUE,
show_colnames = TRUE
)
# rownames(sig_genes), top_hvg,
# 繪製 heatmap
pheatmap(sample_cor,
main = "SPCA cor",
clustering_distance_rows = "euclidean",  # 樣本聚類距離
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("blue", "white", "red"))(100),
show_rownames = TRUE,
show_colnames = TRUE
)
# expr_spca_data: 基因 x 樣本矩陣
# 計算樣本間 Pearson 相關性矩陣
sample_cor <- cor(t(expr_f[intersect(rownames(expr_hvg),rownames(expr_spca)),]))  # 默認 method="pearson"
dim(sample_cor)
intersect(rownames(expr_hvg),rownames(expr_spca)
)
# expr_spca_data: 基因 x 樣本矩陣
# 計算樣本間 Pearson 相關性矩陣
sample_cor <- cor(t(expr_f[intersect(rownames(expr_hvg),rownames(expr_spca)),]))  # 默認 method="pearson"
dim(sample_cor)
# rownames(sig_genes), top_hvg,
# 繪製 heatmap
pheatmap(sample_cor,
main = "SPCA cor",
clustering_distance_rows = "euclidean",  # 樣本聚類距離
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("blue", "white", "red"))(100),
show_rownames = TRUE,
show_colnames = TRUE
)
# expr_spca_data: 基因 x 樣本矩陣
# 計算樣本間 Pearson 相關性矩陣
sample_cor <- cor(t(expr_f[intersect(rownames(res[res$significant == 'yes',]),rownames(res_spca[res_spca$significant == 'yes',])),]))  # 默認 method="pearson"
dim(sample_cor)
# expr_spca_data: 基因 x 樣本矩陣
# 計算樣本間 Pearson 相關性矩陣
sample_cor <- cor(t(expr_f[intersect(rownames(res[res$significant == 'yes',]),rownames(res_spca[res_spca$significant == 'yes',])),]))  # 默認 method="pearson"
dim(sample_cor)
intersect(rownames(res[res$significant == 'yes',]),rownames(res_spca[res_spca$significant == 'yes',]))
length(rownames(res[res$significant == 'yes',]))
# expr_spca_data: 基因 x 樣本矩陣
# 計算樣本間 Pearson 相關性矩陣
sample_cor <- cor(t(expr_f[intersect(rownames(res_hvg[res_hvg$significant == 'yes',]),rownames(res_spca[res_spca$significant == 'yes',])),]))  # 默認 method="pearson"
dim(sample_cor)
# expr_spca_data: 基因 x 樣本矩陣
# 計算樣本間 Pearson 相關性矩陣
sample_cor <- cor(t(expr_f[intersect(rownames(res_hvg[res_hvg$significant == 'yes',]),rownames(res_spca[res_spca$significant == 'yes',])),]))  # 默認 method="pearson"
dim(sample_cor)
source("C:/Users/User/Desktop/program/utaipei_RA/code_TCGA_CRC_forWillie.r/code_TCGA_CRC_forWillie.r", echo = TRUE)
length(HVG_SPCA_inter)
length(TCGA.temp2[rowSums(spca_res$loadings[,1:2] != 0) > 0,1])
length(TCGA.temp2[top_hvg,1])
length(TCGA.temp2[rownames(res_hvg_1[res_hvg_1$significant == 'yes',],])
length(TCGA.temp2[rownames(res_hvg_1[res_hvg_1$significant == 'yes',]),])
top_hvg_dea
length(rownames(res_hvg[res_hvg$significant == 'yes',]))
rownames(pca_hvg)
rownames(pca_hvg$rotation)
pca_hvg$rotation
length(rownames(pca_hvg$rotation))
intersect(rownames(res_hvg[res_hvg$significant == 'yes',]),rownames(pca_hvg$rotation))
length(intersect(rownames(res_hvg[res_hvg$significant == 'yes',]),rownames(pca_hvg$rotation)))
length(rownames(res_hvg[res_hvg$significant == 'yes',]))
length(intersect(rownames(res_hvg[res_hvg$significant == 'yes',]),rownames(res_spca[res_spca$significant == 'yes',])))
length(rownames(res_spca[res_spca$significant == 'yes',]))
DEA_HVG_inter <- intersect(TCGA.temp2[top_hvg,1],res$names)
length(TCGA.temp2[top_hvg,1])
length(DEA_HVG_inter)
length(TCGA.temp2[rowSums(spca_res$loadings[,1:2] != 0) > 0,1])
rowSums(spca_res$loadings[,1:2] != 0) > 0,1]
rowSums(spca_res$loadings[,1:2] != 0) > 0,1
rowSums(spca_res$loadings[,1:2] != 0) >0
length(rowSums(spca_res$loadings[,1:2] != 0) > 0)
length(TCGA.temp2)
dim(TCGA.temp2)
dim(expr_f)
expr_f
View(expr_f)
DEA_HVG_inter <- intersect(TCGA.temp2[rownames(expr_f[top_hvg,]),1],res$names)
length(DEA_HVG_inter)
DEA_HVG_inter
DEA_SPCA_inter <- intersect(TCGA.temp2[rownames(expr_f[rowSums(spca_res$loadings[,1:2] != 0) > 0,1]),1],res$names)
length(TCGA.temp2[rowSums(spca_res$loadings[,1:2] != 0) > 0,1])
length(DEA_SPCA_inter)
length(DEA_SPCA_inter)
DEA_SPCA_inter <- intersect(TCGA.temp2[rownames(expr_f[rowSums(spca_res$loadings[,1:2] != 0) > 0,1]),1],res$names)
length(DEA_SPCA_inter)
TCGA.temp2[rownames(expr_f[rowSums(spca_res$loadings[,1:2] != 0) > 0,1]),1]
rownames(expr_f[rowSums(spca_res$loadings[,1:2] != 0) > 0,1])
expr_f[rowSums(spca_res$loadings[,1:2] != 0) > 0,1]
expr_f[rowSums(spca_res$loadings[,1:2] != 0) > 0,]
DEA_SPCA_inter <- intersect(TCGA.temp2[rownames(expr_f[rowSums(spca_res$loadings[,1:2] != 0) > 0,]),1],res$names)
length(TCGA.temp2[rowSums(spca_res$loadings[,1:2] != 0) > 0,1])
length(DEA_SPCA_inter)
length(TCGA.temp2[rownames(expr_f[rowSums(spca_res$loadings[,1:2] != 0) > 0,]),1])
length(DEA_SPCA_inter)
HVG_SPCA_inter <- intersect(DEA_HVG_inter,DEA_SPCA_inter)
length(HVG_SPCA_inter)
# expr_spca_data: 基因 x 樣本矩陣
# 計算樣本間 Pearson 相關性矩陣
sample_cor <- cor(t(expr_f[intersect(rownames(res_hvg[res_hvg$significant == 'yes',]),rownames(res_spca[res_spca$significant == 'yes',])),]))  # 默認 method="pearson"
dim(sample_cor)
# rownames(sig_genes), top_hvg,
# 繪製 heatmap
pheatmap(sample_cor,
main = "SPCA cor",
clustering_distance_rows = "euclidean",  # 樣本聚類距離
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("blue", "white", "red"))(100),
show_rownames = TRUE,
show_colnames = TRUE
)
HVG_SPCA_inter
intersect(rownames(expr_f[top_hvg,]),rownames(expr_f[rowSums(spca_res$loadings[,1:2] != 0) > 0,]))
TCGA.temp2[intersect(rownames(expr_f[top_hvg,]),rownames(expr_f[rowSums(spca_res$loadings[,1:2] != 0) > 0,])),1]
rownames(sample_cor) <- HVG_SPCA_inter
colnames(sample_cor) <- HVG_SPCA_inter
dim(sample_cor)
# rownames(sig_genes), top_hvg,
# 繪製 heatmap
pheatmap(sample_cor,
main = "SPCA cor",
clustering_distance_rows = "euclidean",  # 樣本聚類距離
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("blue", "white", "red"))(100),
show_rownames = TRUE,
show_colnames = TRUE
)
# rownames(sig_genes), top_hvg,
# 繪製 heatmap
pheatmap(sample_cor,
main = "SPCA and HVG cor",
clustering_distance_rows = "euclidean",  # 樣本聚類距離
clustering_distance_cols = "euclidean",
clustering_method = "complete",
color = colorRampPalette(c("blue", "white", "red"))(100),
show_rownames = TRUE,
show_colnames = TRUE
)
library(VennDiagram)
venn.plot <- draw.triple.venn(
area1 = 4806, # |A|
area2 = 500,  # |B|
area3 = 374,  # |C|
n12   = 500,  # |A ∩ B|
n23   = 29,    # |B ∩ C|
n13   = 374,  # |A ∩ C|
n123  = 29,    # |A ∩ B ∩ C|
category = c("DEA", "HVG", "SPCA"),
fill = c("red", "green", "blue"),
alpha = 0.4,
cex = 2,
cat.cex = 2,
cat.col = c("red", "green", "blue")
)
library(VennDiagram)
venn.plot <- draw.triple.venn(
area1 = 4806, # |A|
area2 = 500,  # |B|
area3 = 374,  # |C|
n12   = 500,  # |A ∩ B|
n23   = 29,    # |B ∩ C|
n13   = 374,  # |A ∩ C|
n123  = 29,    # |A ∩ B ∩ C|
category = c("DEA", "HVG", "SPCA"),
fill = c("red", "green", "blue"),
alpha = 0.4,
cex = 2,
cat.cex = 2,
cat.col = c("red", "green", "blue")
)
source("C:/Users/User/Desktop/program/utaipei_RA/code_TCGA_CRC_forWillie.r/code_TCGA_CRC_forWillie.r", echo = TRUE)
source("C:/Users/User/Desktop/program/utaipei_RA/code_TCGA_CRC_forWillie.r/code_TCGA_CRC_forWillie.r", echo = TRUE)
source("C:/Users/User/Desktop/program/utaipei_RA/code_TCGA_CRC_forWillie.r/code_TCGA_CRC_forWillie.r", echo = TRUE)
<<<<<<< HEAD
=======
##### View survival_COAD_survival.txt  #####
COAD.Clinical<-read.table(file="data/survival_COAD_survival.txt",sep="\t",head=TRUE,quote = "\"")
dim(COAD.Clinical)
colnames(COAD.Clinical)
head(COAD.Clinical)
colSums(is.na(COAD.Clinical[colSums(is.na(COAD.Clinical)) > 0]))
##### View TCGA.COAD.sampleMap_COAD_clinicalMatrix  #####
COAD.Clinical2<-read.table(file="data/TCGA.COAD.sampleMap_COAD_clinicalMatrix",sep="\t",head=TRUE,quote = "\"")
dim(COAD.Clinical2)
colnames(COAD.Clinical2)
head(COAD.Clinical2[,1:10])
colSums(is.na(COAD.Clinical2[colSums(is.na(COAD.Clinical2)) > 0]))
# 1. 基本病人資料
basic_info <- c(
"sampleID", "patient_id", "bcr_patient_barcode", "bcr_sample_barcode", "bcr_followup_barcode",
"gender", "age_at_initial_pathologic_diagnosis", "days_to_birth", "days_to_death",
"days_to_last_followup", "vital_status", "height", "weight", "initial_weight",
"year_of_initial_pathologic_diagnosis", "system_version", "form_completion_date"
)
# 2. 分子與基因相關資訊
molecular_gene <- c(
"MSI_updated_Oct62011", "microsatellite_instability", "CIMP",
"braf_gene_analysis_performed", "braf_gene_analysis_result",
"kras_gene_analysis_performed", "kras_mutation_found", "kras_mutation_codon",
"hypermutation", "loss_expression_of_mismatch_repair_proteins_by_ihc",
"loss_expression_of_mismatch_repair_proteins_by_ihc_result",
"non_silent_mutation", "silent_mutation", "total_mutation",
"non_silent_rate_per_Mb", "silent_rate_per_Mb",
"number_of_abnormal_loci", "number_of_loci_tested"
)
# 3. 臨床診斷與病理
clinical_pathology <- c(
"primary_site", "tumor_tissue_site", "anatomic_neoplasm_subdivision",
"histological_type", "pathologic_T", "pathologic_N", "pathologic_M",
"pathologic_stage", "residual_tumor",
"residual_disease_post_new_tumor_event_margin_status",
"circumferential_resection_margin", "perineural_invasion_present",
"lymphatic_invasion", "venous_invasion",
"lymph_node_examined_count", "number_of_lymphnodes_positive_by_he",
"number_of_lymphnodes_positive_by_ihc", "non_nodal_tumor_deposits", "pathology_report_file_name", "primary_lymph_node_presentation_assessment"
)
# 4. 治療與追蹤
treatment_followup <- c(
"radiation_therapy", "additional_radiation_therapy", "additional_pharmaceutical_therapy",
"postoperative_rx_tx", "preoperative_pretreatment_cea_level",
"primary_therapy_outcome_success", "followup_treatment_success",
"person_neoplasm_cancer_status",
"new_tumor_event_after_initial_treatment", "new_neoplasm_event_type",
"new_tumor_event_additional_surgery_procedure",
"days_to_new_tumor_event_after_initial_treatment",
"days_to_new_tumor_event_additional_surgery_procedure",
"history_of_neoadjuvant_treatment", "lost_follow_up",
"followup_case_report_form_submission_reason", "site_of_additional_surgery_new_tumor_event_mets"
)
# 5. 其他病史與檢查
history_other <- c(
"history_of_colon_polyps", "colon_polyps_present", "synchronous_colon_cancer_present",
"number_of_first_degree_relatives_with_cancer_diagnosis",
"icd_10", "icd_o_3_histology", "icd_o_3_site",
"informed_consent_verified",
"AWG_MLH1_silencing", "AWG_cancer_type_Oct62011", "CDE_ID_3226963", "disease_code"
)
# 6. TCGA 整合與多組學欄位
tcga_multiomics <- c(
grep("^X_", colnames(COAD.Clinical2), value = TRUE),  # 所有 X_ 開頭的欄位
"project_code", "X_cohort", "X_primary_disease", "X_primary_site"
)
# 7. 樣本/檢體資訊
sample_info <- c(
"days_to_collection", "days_to_initial_pathologic_diagnosis", "intermediate_dimension", "longest_dimension", "shortest_dimension",
"is_ffpe", "oct_embedded", "sample_type", "sample_type_id",
"tissue_prospective_collection_indicator", "tissue_retrospective_collection_indicator",
"tissue_source_site", "vial_number"
)
# Load expression data: Assumed to be log2(RSEM + 1)
coad_hiseq_logrsem<-read.table(file="data/TCGA.COAD.sampleMap_HiSeqV2.data",sep="\t",head=TRUE,quote = "\"")
head(coad_hiseq_logrsem[,1:10])
coad_gav2_logrsem<-read.table(file="data/TCGA.COAD.sampleMap_GAV2.data",sep="\t",head=TRUE,quote = "\"")
head(coad_gav2_logrsem[,1:10])
dim(coad_gav2_logrsem)
dim(coad_hiseq_logrsem)
# Match tumor cells by patient (Sample type "-01")
COAD.T.index <- match(unique(paste0(COAD.Clinical$X_PATIENT, "-01")), COAD.Clinical$sample, nomatch = 0)
# Match tumor cells by patient (Sample type "-01")
COAD.T.index <- match(unique(paste0(COAD.Clinical$X_PATIENT, "-01")), COAD.Clinical$sample, nomatch = 0)
<<<<<<< HEAD
sum(COAD.T.index != 0)  # Count how many tumor samples were successfully matched
# Match normal cells by patient
COAD.N.index <- match(unique(paste0(COAD.Clinical$X_PATIENT, "-11")), COAD.Clinical$sample, nomatch = 0)
sum(COAD.N.index != 0)  # Count how many normal samples were successfully matched
# Find patients who have both tumor and normal cells
COAD.matchT.index <- match(unique(paste0(COAD.Clinical$X_PATIENT[COAD.N.index], "-01")), COAD.Clinical$sample, nomatch = 0)
cbind(COAD.Clinical$sample[COAD.matchT.index], COAD.Clinical$sample[COAD.N.index])  # Combine matched tumor-normal sample pairs
# Extract tumor patient clinical data
COAD.Clinical.T <- COAD.Clinical[COAD.T.index,]
# Identify the patient's tumor cells using GAV2
common.names <- intersect(substr(colnames(TCGA.temp), 1, 15), make.names(COAD.Clinical.T$sample))
common.names
length(common.names)  # Count common names
# Identify the patient's tumor cells using HiSeqV2
common.names2 <- intersect(substr(colnames(TCGA.temp2), 1, 15), make.names(COAD.Clinical.T$sample))
common.names2
length(common.names2)  # Count common names
# Identify the patient's normal cells using HiSeqV2
common.namesN <- intersect(substr(colnames(TCGA.temp2), 1, 15), make.names(COAD.Clinical$sample[COAD.N.index]))
common.namesN
length(common.namesN)  # Count common names
#### Analysis ####
#### 建立 DESeq2 物件 ####
library(DESeq2)
library(ggplot2)
library(pheatmap)
installed.packages(pheatmap)
install.packages("pheatmap")
library(pheatmap)
# tumor + normal counts
tumor.counts <- TCGA.temp2[, common.names2]
normal.counts <- TCGA.temp2[, common.namesN]
all.counts <- cbind(tumor.counts, normal.counts)
# 樣本資訊
sample.type <- c(rep("Tumor", length(common.names2)),
rep("Normal", length(common.namesN)))
colData <- data.frame(row.names = colnames(all.counts),
condition = sample.type)
# 建立 dds
dds <- DESeqDataSetFromMatrix(
countData = round(all.counts),  # counts 必須是整數
colData = colData,
design = ~ condition
)
View(dds)
counts(dds)
dds
counts(dds)[:1:10]
counts(dds)[,1:10]
all.counts
View(TCGA.temp2)
<<<<<<< HEAD
>>>>>>> 83a24d3 (Version 3)
=======
##### View survival_COAD_survival.txt  #####
COAD.Clinical<-read.table(file="data/survival_COAD_survival.txt",sep="\t",head=TRUE,quote = "\"")
dim(COAD.Clinical)
colnames(COAD.Clinical)
head(COAD.Clinical)
colSums(is.na(COAD.Clinical[colSums(is.na(COAD.Clinical)) > 0]))
##### View TCGA.COAD.sampleMap_COAD_clinicalMatrix  #####
COAD.Clinical2<-read.table(file="data/TCGA.COAD.sampleMap_COAD_clinicalMatrix",sep="\t",head=TRUE,quote = "\"")
dim(COAD.Clinical2)
colnames(COAD.Clinical2)
head(COAD.Clinical2[,1:10])
colSums(is.na(COAD.Clinical2[colSums(is.na(COAD.Clinical2)) > 0]))
View(COAD.Clinical2)
##### View survival_COAD_survival.txt  #####
COAD.Clinical<-read.table(file="data/survival_COAD_survival.txt",sep="\t",head=TRUE,quote = "\"")
dim(COAD.Clinical)
colnames(COAD.Clinical)
head(COAD.Clinical)
colSums(is.na(COAD.Clinical[colSums(is.na(COAD.Clinical)) > 0]))
##### View TCGA.COAD.sampleMap_COAD_clinicalMatrix  #####
COAD.Clinical2<-read.table(file="data/TCGA.COAD.sampleMap_COAD_clinicalMatrix",sep="\t",head=TRUE,quote = "\"")
dim(COAD.Clinical2)
colnames(COAD.Clinical2)
head(COAD.Clinical2[,1:10])
colSums(is.na(COAD.Clinical2[colSums(is.na(COAD.Clinical2)) > 0]))
#### TCGA.COAD.sampleMap_HiSeqV2 AND TCGA.COAD.sampleMap_GAV2 ####
TCGA.temp2<-read.table(file="data/TCGA.COAD.sampleMap_HiSeqV2.data",sep="\t",head=TRUE,quote = "\"")
head(TCGA.temp2[,1:10])
TCGA.temp<-read.table(file="data/TCGA.COAD.sampleMap_GAV2.data",sep="\t",head=TRUE,quote = "\"")
head(TCGA.temp[,1:10])
dim(TCGA.temp)
dim(TCGA.temp2)
>>>>>>> 19d151a (Version 4)
=======
sum(COAD.T.index != 0)  # Count matched tumor samples
source("C:/Users/User/Desktop/program/utaipei_RA/code_TCGA_CRC_forWillie.r/code_TCGA_CRC_forWillie.r", echo = TRUE)
library(glmnet)
install.packages("glmnet")
X <- t(expr_all_filtered)  # glmnet 要用樣本 x 特徵
group_main <- factor(c(rep("Tumor",  ncol(expr_tumor_hiseq)),
rep("Normal", ncol(expr_normal_hiseq)),
rep("Tumor",  ncol(expr_tumor_ga))))
y <- as.factor(group_main)
# 轉成二元 0/1 (Tumor=1, Normal=0)
y_bin <- ifelse(y == "Tumor", 1, 0)
# 建立 LASSO logistic regression
set.seed(123)
cvfit <- cv.glmnet(X, y_bin, family="binomial", alpha=1, nfolds=10)
library(glmnet)
cvfit <- cv.glmnet(X, y_bin, family="binomial", alpha=1, nfolds=10)
# 找最佳 lambda
best_lambda <- cvfit$lambda.min
cat("Best lambda:", best_lambda, "\n")
# 用最佳 lambda 重新訓練
lasso_fit <- glmnet(X, y_bin, family="binomial", alpha=1, lambda=best_lambda)
# 提取非零係數基因 (被 LASSO 選中的特徵)
coef_lasso <- coef(lasso_fit)
selected_genes <- rownames(coef_lasso)[which(coef_lasso != 0)]
selected_genes <- selected_genes[-1]  # 去掉 intercept
cat("Number of selected genes:", length(selected_genes), "\n")
head(selected_genes)
dim(X)
y
dim(y)
length(y)
coef_lasso
lasso_fit
plot(cvfit)
coef(cvfit, s = "lambda.min")
coef(cvfit, s = "lambda.1se")
# 找最佳 lambda
best_lambda <- cvfit$lambda.1se
cat("Best lambda:", best_lambda, "\n")
# 用最佳 lambda 重新訓練
lasso_fit <- glmnet(X, y_bin, family="binomial", alpha=1, lambda=best_lambda)
lasso_fit
View(expr_spca_hvg_dea)
X <- as.matrix(t(expr_hvg_all))  # glmnet 要用樣本 x 特徵
group_main <- factor(c(rep("Tumor",  ncol(expr_tumor_hiseq)),
rep("Normal", ncol(expr_normal_hiseq)),
rep("Tumor",  ncol(expr_tumor_ga))))
y <- as.factor(group_main)
# 轉成二元 0/1 (Tumor=1, Normal=0)
y_bin <- ifelse(y == "Tumor", 1, 0)
# 建立 LASSO logistic regression
set.seed(123)
cvfit <- cv.glmnet(X, y_bin, family="binomial", alpha=1, nfolds=10)
# 找最佳 lambda
best_lambda <- cvfit$lambda.1se
cat("Best lambda:", best_lambda, "\n")
# 用最佳 lambda 重新訓練
lasso_fit <- glmnet(X, y_bin, family="binomial", alpha=1, lambda=best_lambda)
# 提取非零係數基因 (被 LASSO 選中的特徵)
coef_lasso <- coef(lasso_fit)
selected_genes <- rownames(coef_lasso)[which(coef_lasso != 0)]
selected_genes <- selected_genes[-1]  # 去掉 intercept
cat("Number of selected genes:", length(selected_genes), "\n")
head(selected_genes)
coad_hiseq_logrsem[selected_genes,1]
expr_hvg_2000_m
expr_hvg_2000
X <- as.matrix(t(expr_hvg_2000))  # glmnet 要用樣本 x 特徵
group_main <- factor(c(rep("Tumor",  ncol(expr_tumor_hiseq)),
rep("Normal", ncol(expr_normal_hiseq))
))
y <- as.factor(group_main)
# 轉成二元 0/1 (Tumor=1, Normal=0)
y_bin <- ifelse(y == "Tumor", 1, 0)
# 建立 LASSO logistic regression
set.seed(123)
cvfit <- cv.glmnet(X, y_bin, family="binomial", alpha=1, nfolds=10)
# 找最佳 lambda
best_lambda <- cvfit$lambda.1se
cat("Best lambda:", best_lambda, "\n")
# 用最佳 lambda 重新訓練
lasso_fit <- glmnet(X, y_bin, family="binomial", alpha=1, lambda=best_lambda)
# 提取非零係數基因 (被 LASSO 選中的特徵)
coef_lasso <- coef(lasso_fit)
selected_genes <- rownames(coef_lasso)[which(coef_lasso != 0)]
selected_genes <- selected_genes[-1]  # 去掉 intercept
cat("Number of selected genes:", length(selected_genes), "\n")
coad_hiseq_logrsem[selected_genes,1]
##################################################################
### Optional: 可視化基因數量 vs lambda
##################################################################
plot(cvfit)
intersect(selected_genes,gene_indices_to_plot)
gene_indices_to_plot
intersect(selected_genes,gene_indices_to_plot)
selected_genes
coad_hiseq_logrsem[selected_genes,1]
>>>>>>> 9530aed (Add week 4)
